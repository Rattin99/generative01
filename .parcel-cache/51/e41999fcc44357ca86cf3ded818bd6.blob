var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shadedBoxes", ()=>shadedBoxes
);
var _tinycolor2 = require("tinycolor2");
var _tinycolor2Default = parcelHelpers.interopDefault(_tinycolor2);
var _particle = require("../systems/Particle");
var _canvas = require("../lib/canvas/canvas");
var _math = require("../lib/math/math");
var _sketch = require("../lib/Sketch");
var _palettes = require("../lib/color/palettes");
var _box = require("../lib/canvas/Box");
var _attractors = require("../lib/math/attractors");
var _vector = require("../lib/math/Vector");
var _canvasTextures = require("../lib/canvas/canvas-textures");
var _canvasParticles = require("../lib/canvas/canvas-particles");
var _grids = require("../lib/math/grids");
const shadedBoxes = ()=>{
    const config = {
        name: 'shadedBoxes',
        ratio: _sketch.ratio.square,
        scale: _sketch.scale.standard
    };
    const numParticles = 30;
    let canvasCenterX;
    let canvasCenterY;
    let centerRadius;
    let grid;
    const boxes = [];
    const palette = _palettes.palettes.pop;
    let time = 0;
    const setup = ({ canvas , context  })=>{
        canvasCenterX = canvas.width / 2;
        canvasCenterY = canvas.height / 2;
        centerRadius = canvas.height / 4;
        _canvas.background(canvas, context)(_palettes.paperWhite);
        const boxwhite = _palettes.paperWhite.clone().darken(10).saturate(10);
        const boxbg = [
            boxwhite, _palettes.bicPenBlue];
        const boxfg = [_palettes.bicPenBlue, boxwhite
        ];
        const gridMargin = Math.round(canvas.width / 10);
        const gridGutter = Math.round(gridMargin / 4);
        grid = _grids.createGridCellsXY(canvas.width, canvas.height, 1, 10, gridMargin, gridGutter);
        grid.points.forEach((p, i)=>{
            boxes.push(new _box.Box({
                canvas,
                context,
                x: p[0],
                y: p[1],
                width: grid.columnWidth,
                height: grid.rowHeight
            }));
        });
        let freq = 0.0001;
        boxes.forEach((b, bidx)=>{
            const particles = [];
            const clr = bidx % 2 === 0 ? 0 : 1;
            b.backgroundColor = _palettes.bicPenBlue.clone(); // boxbg[clr];
            b.flowField = (x, y, t)=>_attractors.simplexNoise3d(x, y, t, freq)
            ;
            freq += 0.0005;
            for(let i = 0; i < numParticles; i++){
                const props = _particle.createRandomParticleValues(canvas);
                const coords = b.translateInto(b.randomPointInside('normal'));
                props.x = coords.x;
                props.y = coords.y;
                props.velocityX = 0;
                props.velocityY = 0;
                props.radius = 1;
                props.color = bidx <= 4 ? _palettes.bicPenBlue.clone() : _palettes.paperWhite.clone(); // tinycolor(boxfg[clr]).clone().setAlpha(0.5);
                particles.push(new _particle.Particle(props));
            }
            b.children = particles;
            _canvasTextures.stippleRect(context)(b.x, b.y, b.width, b.height, b.backgroundColor, bidx + 1);
        });
        // boxes.forEach((b) => {
        //     b.fill();
        // });
        return -1;
    };
    const draw = ({ canvas , context  })=>{
        boxes.forEach((box)=>{
            box.createClip();
            box.children.forEach((particle)=>{
                const theta = box.flowField(particle.x, particle.y, time);
                const force = _math.uvFromAngle(theta);
                particle.applyForce(force);
                particle.velocity = particle.velocity.limit(1);
                particle.updatePosWithVelocity();
                particle.acceleration = new _vector.Vector(0, 0);
                box.particleEdgeWrap(particle);
                _canvas.pixel(context)(particle.x, particle.y, particle.color, 'circle', 0.5);
            });
            box.removeClip();
        });
        time += 0.1;
    };
    return {
        config,
        setup,
        draw
    };
};
