var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "golden", ()=>golden
);
parcelHelpers.export(exports, "checkBoundsLeft", ()=>checkBoundsLeft
);
parcelHelpers.export(exports, "checkBoundsRight", ()=>checkBoundsRight
);
parcelHelpers.export(exports, "snapNumber", ()=>snapNumber
);
parcelHelpers.export(exports, "percentage", ()=>percentage
);
parcelHelpers.export(exports, "houghQuantize", ()=>houghQuantize
);
parcelHelpers.export(exports, "quantize", ()=>quantize
);
parcelHelpers.export(exports, "round2", ()=>round2
);
parcelHelpers.export(exports, "getRandomSeed", ()=>getRandomSeed
);
parcelHelpers.export(exports, "setRandomSeed", ()=>setRandomSeed
);
parcelHelpers.export(exports, "randomNormalBM", ()=>randomNormalBM
);
parcelHelpers.export(exports, "randomNormalBM2", ()=>randomNormalBM2
);
parcelHelpers.export(exports, "randomNormalNumberBetween", ()=>randomNormalNumberBetween
);
parcelHelpers.export(exports, "randomNormalWholeBetween", ()=>randomNormalWholeBetween
);
parcelHelpers.export(exports, "randomNumberBetween", ()=>randomNumberBetween
);
parcelHelpers.export(exports, "randomWholeBetween", ()=>randomWholeBetween
);
parcelHelpers.export(exports, "randomNumberBetweenMid", ()=>randomNumberBetweenMid
);
parcelHelpers.export(exports, "randomSign", ()=>randomSign
);
parcelHelpers.export(exports, "randomBoolean", ()=>randomBoolean
);
parcelHelpers.export(exports, "randomChance", ()=>randomChance
);
parcelHelpers.export(exports, "averageNumArray", ()=>averageNumArray
);
parcelHelpers.export(exports, "oneOf", ()=>oneOf
);
parcelHelpers.export(exports, "lowest", ()=>lowest
);
parcelHelpers.export(exports, "highest", ()=>highest
);
parcelHelpers.export(exports, "createRandomNumberArray", ()=>createRandomNumberArray
);
parcelHelpers.export(exports, "loopingValue", ()=>loopingValue
);
parcelHelpers.export(exports, "pingPontValue", ()=>pingPontValue
);
parcelHelpers.export(exports, "pointOnCircle", ()=>pointOnCircle
);
parcelHelpers.export(exports, "normalize", ()=>normalize
);
parcelHelpers.export(exports, "normalizeInverse", ()=>normalizeInverse
);
parcelHelpers.export(exports, "lerp", ()=>lerp
);
parcelHelpers.export(exports, "clamp", ()=>clamp
);
parcelHelpers.export(exports, "invlerp", ()=>invlerp
);
parcelHelpers.export(exports, "mapRange", ()=>mapRange
);
parcelHelpers.export(exports, "toSinValue", ()=>toSinValue
);
parcelHelpers.export(exports, "mapToTau", ()=>mapToTau
);
parcelHelpers.export(exports, "logInterval", ()=>logInterval
);
parcelHelpers.export(exports, "marginify", ()=>marginify
);
parcelHelpers.export(exports, "pointDistance", ()=>pointDistance
);
parcelHelpers.export(exports, "pointRotateCoord", ()=>pointRotateCoord
);
parcelHelpers.export(exports, "pointAngleFromVelocity", ()=>pointAngleFromVelocity
);
parcelHelpers.export(exports, "aFromVector", ()=>aFromVector
);
parcelHelpers.export(exports, "uvFromAngle", ()=>uvFromAngle
);
parcelHelpers.export(exports, "radiansToDegrees", ()=>radiansToDegrees
);
parcelHelpers.export(exports, "degreesToRadians", ()=>degreesToRadians
);
parcelHelpers.export(exports, "scalePointToCanvas", ()=>scalePointToCanvas
);
parcelHelpers.export(exports, "create2dNoise", ()=>create2dNoise
);
parcelHelpers.export(exports, "create2dNoiseAbs", ()=>create2dNoiseAbs
);
parcelHelpers.export(exports, "create3dNoise", ()=>create3dNoise
);
parcelHelpers.export(exports, "create3dNoiseAbs", ()=>create3dNoiseAbs
);
parcelHelpers.export(exports, "randomPointAround", ()=>randomPointAround
);
parcelHelpers.export(exports, "chaikin", ()=>chaikin
);
parcelHelpers.export(exports, "valueCloseTo", ()=>valueCloseTo
);
/*
  Math Snippets
  https://github.com/terkelg/math
*/ var _random = require("canvas-sketch-util/random");
var _randomDefault = parcelHelpers.interopDefault(_random);
var _vector = require("./Vector");
// Math aliases
const Ï€ = Math.PI;
const { PI  } = Math;
const TAU = Math.PI * 2;
const { abs  } = Math;
const { sin  } = Math;
const { cos  } = Math;
const { tan  } = Math;
const { pow  } = Math;
const { round  } = Math;
const { floor  } = Math;
_randomDefault.default.setSeed(_randomDefault.default.getRandomSeed());
console.log(`Using seed ${_randomDefault.default.getSeed()}`);
const golden = 1.618033988749895;
const checkBoundsLeft = (b, v)=>v < b ? b : v
;
const checkBoundsRight = (b, v)=>v > b ? b : v
;
const snapNumber = (snap, n)=>Math.floor(n / snap) * snap
;
const percentage = (total, num)=>Math.round(num * (total / 100))
;
const houghQuantize = (numAngles, theta)=>Math.floor(numAngles * theta / TAU + 0.5)
;
const quantize = (numAngles, theta)=>(Math.round(theta * (numAngles / Math.PI)) + numAngles) % numAngles
;
const round2 = (num)=>Math.round((num + Number.EPSILON) * 100) / 100
;
const getRandomSeed = ()=>_randomDefault.default.getSeed()
;
const setRandomSeed = (s)=>_randomDefault.default.setRandomSeed(s)
;
const randomNormalBM = ()=>{
    let u = 0;
    let v = 0;
    while(u === 0)u = _randomDefault.default.value(); // Converting [0,1) to (0,1)
    while(v === 0)v = _randomDefault.default.value();
    let num = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    num = num / 10 + 0.5; // Translate to 0 -> 1
    if (num > 1 || num < 0) return randomNormalBM(); // resample between 0 and 1
    return num;
};
const randomNormalBM2 = (min = 0, max = 1, skew = 1)=>{
    let u = 0;
    let v = 0;
    while(u === 0)u = _randomDefault.default.value(); // Converting [0,1) to (0,1)
    while(v === 0)v = _randomDefault.default.value();
    let num = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    num = num / 10 + 0.5; // Translate to 0 -> 1
    if (num > 1 || num < 0) // // resample between 0 and 1 if out of range
    num = randomNormalBM2(min, max, skew);
    else {
        num = Math.pow(num, skew); // Skew
        num *= max - min; // Stretch to fill range
        num += min; // offset to min
    }
    return num;
};
const randomNormalNumberBetween = (min, max)=>randomNormalBM() * (max - min) + min
;
const randomNormalWholeBetween = (min, max)=>Math.round(randomNormalBM() * (max - min) + min)
;
const randomNumberBetween = (min, max)=>_randomDefault.default.valueNonZero() * (max - min) + min
;
const randomWholeBetween = (min, max)=>Math.floor(_randomDefault.default.value() * (max - min) + min)
;
const randomNumberBetweenMid = (min, max)=>randomNumberBetween(min, max) - max / 2
;
const randomSign = ()=>Math.round(_randomDefault.default.value()) === 1 ? 1 : -1
;
const randomBoolean = ()=>Math.round(_randomDefault.default.value()) === 1
;
const randomChance = (chance = 0.5)=>_randomDefault.default.chance(chance)
;
const averageNumArray = (arry)=>arry.reduce((a, b)=>a + b
    ) / arry.length
;
const oneOf = (arry)=>{
    const i = randomWholeBetween(0, arry.length - 1);
    return arry[i];
};
const lowest = (arry)=>arry.reduce((acc, v)=>{
        if (v < acc) acc = v;
        return acc;
    }, 0)
;
const highest = (arry)=>arry.reduce((acc, v)=>{
        if (v > acc) acc = v;
        return acc;
    }, 0)
;
const createRandomNumberArray = (len, min, max)=>Array.from(new Array(len)).map(()=>randomNumberBetween(min, max)
    )
;
const loopingValue = (t, m = 0.5)=>Math.sin(t * m)
;
const pingPontValue = (t)=>Math.sin(t * Math.PI)
;
const pointOnCircle = (x, y, r, a)=>({
        x: r * Math.sin(a) + x,
        y: r * Math.cos(a) + y
    })
;
const normalize = (min, max, val)=>(val - min) / (max - min)
;
const normalizeInverse = (min, max, val)=>1 - normalize(min, max, val)
;
const lerp = (x, y, a)=>x * (1 - a) + y * a
;
const clamp = (min = 0, max = 1, a)=>Math.min(max, Math.max(min, a))
;
const invlerp = (x, y, a)=>clamp(0, 1, (a - x) / (y - x))
;
const mapRange = (x1, y1, x2, y2, a)=>lerp(x2, y2, invlerp(x1, y1, a))
;
const toSinValue = (value)=>Math.abs(Math.sin(value * TAU))
;
const mapToTau = (start, end, value)=>mapRange(start, end, 0, TAU, value)
;
const logInterval = (total_intervals, start, end)=>{
    const startInterVal = 1;
    const endInterval = total_intervals;
    const minLog = Math.log(start);
    const maxLog = Math.log(end);
    const scale = (maxLog - minLog) / (endInterval - startInterVal);
    const result = [];
    for(let i = 1; i < total_intervals; i++)result.push(Math.exp(minLog + scale * (i - startInterVal)));
    result.push(end);
    return result;
};
const marginify = ({ margin , u , v , width , height  })=>({
        x: lerp(margin, width - margin, u),
        y: lerp(margin, height - margin, v)
    })
;
const pointDistance = (pointA, pointB)=>{
    const dx = pointA.x - pointB.x;
    const dy = pointA.y - pointB.y;
    return Math.sqrt(dx * dx + dy * dy);
};
const pointRotateCoord = (point, angle)=>({
        x: point.x * cos(angle) - point.y * sin(angle),
        y: point.y * cos(angle) + point.x * sin(angle)
    })
;
const pointAngleFromVelocity = ({ velocityX , velocityY  })=>Math.atan2(velocityY, velocityX)
;
const aFromVector = ({ x , y  })=>Math.atan2(y, x)
;
const uvFromAngle = (a)=>new _vector.Vector(Math.cos(a), Math.sin(a))
;
const radiansToDegrees = (rad)=>rad * 180 / Math.PI
;
const degreesToRadians = (deg)=>deg * Math.PI / 180
;
const scalePointToCanvas = (canvasWidth, canvasHeight, width, height, zoomFactor, x, y)=>{
    const particleXOffset = canvasWidth / 2 - width * zoomFactor / 2;
    const particleYOffset = canvasHeight / 2 - height * zoomFactor / 2;
    return {
        x: x * zoomFactor + particleXOffset,
        y: y * zoomFactor + particleYOffset
    };
};
const create2dNoise = (u, v, amplitude = 1, frequency = 0.5)=>_randomDefault.default.noise2D(u * frequency, v * frequency) * amplitude
;
const create2dNoiseAbs = (u, v, amplitude = 1, frequency = 0.5)=>Math.abs(_randomDefault.default.noise2D(u * frequency, v * frequency)) * amplitude
;
const create3dNoise = (u, v, t, amplitude = 1, frequency = 0.5)=>_randomDefault.default.noise3D(u * frequency, v * frequency, t * frequency) * amplitude
;
const create3dNoiseAbs = (u, v, t, amplitude = 1, frequency = 0.5)=>Math.abs(_randomDefault.default.noise3D(u * frequency, v * frequency, t * frequency)) * amplitude
;
const randomPointAround = (range = 20)=>{
    const radius = randomWholeBetween(0, range);
    const angle = randomNumberBetween(0, TAU);
    return {
        x: radius * Math.cos(angle),
        y: radius * Math.sin(angle)
    };
};
const chaikin = (input, itr = 1)=>{
    if (itr === 0) return input;
    const output = [];
    for(let i = 0; i < input.length - 1; i++){
        const p0 = input[i];
        const p1 = input[i + 1];
        const p0x = p0[0];
        const p0y = p0[1];
        const p1x = p1[0];
        const p1y = p1[1];
        const Q = [
            0.75 * p0x + 0.25 * p1x,
            0.75 * p0y + 0.25 * p1y
        ];
        const R = [
            0.25 * p0x + 0.75 * p1x,
            0.25 * p0y + 0.75 * p1y
        ];
        output.push(Q);
        output.push(R);
    }
    return itr === 1 ? output : chaikin(output, itr - 1);
};
const valueCloseTo = (testVal, val, range)=>{
    if (val === testVal) return true;
    if (val - range < testVal && val + range > testVal) return true;
    return false;
};
