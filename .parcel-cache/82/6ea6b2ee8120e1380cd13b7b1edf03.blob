var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flowFieldParticles", ()=>flowFieldParticles
);
var _tinycolor2 = require("tinycolor2");
var _tinycolor2Default = parcelHelpers.interopDefault(_tinycolor2);
var _math = require("../lib/math/math");
var _particle = require("../systems/Particle");
var _canvas = require("../lib/canvas/canvas");
var _sketch = require("../lib/Sketch");
var _vector = require("../lib/math/Vector");
var _attractors = require("../lib/math/attractors");
var _palettes = require("../lib/color/palettes");
const flowFieldParticles = ()=>{
    const config = {
        name: 'flowFieldParticles',
        ratio: _sketch.ratio.square,
        scale: _sketch.scale.standard
    };
    const numParticles = 400;
    const particlesArray = [];
    const maxSize = 3;
    let time = 0;
    const createRandomParticle = (canvas)=>{
        const props = _particle.createRandomParticleValues(canvas);
        props.x = _math.randomWholeBetween(0, canvas.width);
        props.y = _math.randomWholeBetween(0, canvas.height);
        props.velocityX = 0;
        props.velocityY = 0;
        return new _particle.Particle(props);
    };
    const setup = ({ canvas , context  })=>{
        for(let i = 0; i < numParticles; i++)particlesArray.push(createRandomParticle(canvas));
        _canvas.background(canvas, context)('rgba(50,50,50,1)');
    };
    const drawPixel = (canvas, context, force, particle, color, rad = 1)=>{
        particle.applyForce(force);
        particle.velocity = particle.velocity.limit(1);
        particle.updatePosWithVelocity();
        _particle.edgeWrap(canvas, particle);
        const pcolor = color || particle.color;
        const x = _math.snapNumber(maxSize * 2, particle.x);
        const y = _math.snapNumber(maxSize * 2, particle.y);
        _canvas.drawCircleFilled(context)(x, y, rad, pcolor);
        return true;
    };
    const drawParticles = ({ canvas , context  })=>{
        for(let i = 0; i < numParticles; i++){
            const particle = particlesArray[i];
            const sNoise3d = _attractors.simplexNoise3d(particle.x, particle.y, time, 0.002);
            const theta = _math.quantize(3, sNoise3d);
            const force = _math.uvFromAngle(theta);
            const clr = _palettes.hslFromRange(5, 270, 360, Math.abs(theta)).setAlpha(0.25);
            const size = _math.mapRange(0, 5, 1, maxSize, Math.abs(theta));
            drawPixel(canvas, context, force, particle, clr, size);
            particle.acceleration = new _vector.Vector(0, 0);
        }
    };
    const drawFibers = ({ canvas , context  })=>{
        const particle = createRandomParticle(canvas);
        const length = 200;
        for(let i = 0; i < length; i++){
            const sNoise3d = _attractors.simplexNoise3d(particle.x, particle.y, time, 0.002);
            const theta = sNoise3d;
            const force = _math.uvFromAngle(theta);
            const clr = 'rgba(0,0,0,.05)';
            drawPixel(canvas, context, force, particle, clr, 1);
            particle.acceleration = new _vector.Vector(0, 0);
        }
    };
    const draw = ({ canvas , context  })=>{
        drawFibers({
            canvas,
            context
        });
        drawParticles({
            canvas,
            context
        });
        time += 0.01;
    };
    return {
        config,
        setup,
        draw
    };
};
