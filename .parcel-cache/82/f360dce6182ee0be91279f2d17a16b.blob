var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "triangleArea2", ()=>triangleArea2
);
parcelHelpers.export(exports, "mCurvature", ()=>mCurvature
);
parcelHelpers.export(exports, "lineSlope", ()=>lineSlope
);
parcelHelpers.export(exports, "linesIntersect", ()=>linesIntersect
);
parcelHelpers.export(exports, "segmentsIntersect", ()=>segmentsIntersect
);
parcelHelpers.export(exports, "segment", ()=>segment
);
parcelHelpers.export(exports, "connectSegments", ()=>connectSegments
);
parcelHelpers.export(exports, "trimSegments", ()=>trimSegments
);
parcelHelpers.export(exports, "startPointsOnly", ()=>startPointsOnly
);
parcelHelpers.export(exports, "getSegPointsMid", ()=>getSegPointsMid
);
parcelHelpers.export(exports, "trimPoints", ()=>trimPoints
);
parcelHelpers.export(exports, "pointsOrientation", ()=>pointsOrientation
);
parcelHelpers.export(exports, "segmentOrientation", ()=>segmentOrientation
);
parcelHelpers.export(exports, "segmentFromPoints", ()=>segmentFromPoints
);
parcelHelpers.export(exports, "pointsFromSegment", ()=>pointsFromSegment
);
parcelHelpers.export(exports, "a2p", ()=>a2p
);
parcelHelpers.export(exports, "a2V", ()=>a2V
);
parcelHelpers.export(exports, "v2a", ()=>v2a
);
parcelHelpers.export(exports, "a2pA", ()=>a2pA
);
parcelHelpers.export(exports, "pa2VA", ()=>pa2VA
);
parcelHelpers.export(exports, "va2pA", ()=>va2pA
);
parcelHelpers.export(exports, "flattenPointArray", ()=>flattenPointArray
);
parcelHelpers.export(exports, "unflattenPointArray", ()=>unflattenPointArray
);
parcelHelpers.export(exports, "createSplinePoints", ()=>createSplinePoints
);
parcelHelpers.export(exports, "reduceLineFromStart", ()=>reduceLineFromStart
);
parcelHelpers.export(exports, "reduceLineFromEnd", ()=>reduceLineFromEnd
);
parcelHelpers.export(exports, "reduceLineEqually", ()=>reduceLineEqually
);
parcelHelpers.export(exports, "intersect", ()=>intersect
);
var _vector = require("./Vector");
var _math = require("./math");
var _curveCalc = require("../community/curve-calc");
var _utils = require("../utils");
const triangleArea2 = (a, b, c)=>(b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)
;
const mCurvature = (p1, p2, p3)=>{
    const t4 = 2 * triangleArea2(p1, p2, p3);
    const la = _math.pointDistance(p1, p2);
    const lb = _math.pointDistance(p2, p3);
    const lc = _math.pointDistance(p3, p1);
    return t4 / (la * lb * lc);
};
const lineSlope = (a, b)=>(b.y - a.y) / (b.x - a.x)
;
const linesIntersect = (a, b, c, d, p, q, r, s)=>{
    const det = (c - a) * (s - q) - (r - p) * (d - b);
    if (det === 0) return false;
    const lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
    const gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
    return lambda > 0 && lambda < 1 && gamma > 0 && gamma < 1;
};
const segmentsIntersect = (a, b)=>linesIntersect(a.start.x, a.start.y, a.end.x, a.end.y, b.start.x, b.start.y, b.end.x, b.end.y)
;
const segment = (x1, y1, x2, y2)=>{
    const start = new _vector.Vector(x1, y1);
    const end = new _vector.Vector(x2, y2);
    return {
        start,
        end
    };
};
const connectSegments = (segs)=>segs.map((s, i)=>{
        if (i === segs.length - 1) return s;
        const next = segs[i + 1];
        const distance = _math.pointDistance({
            x: s.end.x,
            y: s.end.y
        }, {
            x: next.start.x,
            y: s.start.y
        });
        if (distance > 1) s.end = new _vector.Vector(next.start.x, next.start.y);
        return s;
    })
;
const trimSegments = (segs, skip = 2)=>segs.reduce((acc, s, i)=>{
        if (i === 0 || i === segs.length - 1) acc.push(s);
        else if (i % skip === 0) acc.push(s);
        return acc;
    }, [])
;
const startPointsOnly = (points)=>{
    const p = [];
    for(let i = 0; i < points.length; i += 2)p.push(points[i]);
    // last end point
    p.push(_utils.last(points));
    return p;
};
const getSegPointsMid = (points)=>{
    const p = [];
    for(let i = 0; i < points.length; i += 2){
        const s = points[i];
        const e = points[i + 1];
        if (e) {
            const midX = s[0] + (e[0] - s[0]) * 0.5;
            const midY = s[1] + (e[1] - s[1]) * 0.5;
            p.push([
                midX,
                midY
            ]);
        } else p.push(s);
    }
    // last end point
    p.push(_utils.last(points));
    return p;
};
const trimPoints = (points, skip = 2)=>points.reduce((acc, s, i)=>{
        if (i === 0 || i === points.length - 1) acc.push(s);
        else if (i % skip === 0) acc.push(s);
        return acc;
    }, [])
;
const pointsOrientation = (a, b)=>Math.atan2(b.y - a.y, b.x - a.x)
;
const segmentOrientation = ({ start , end  })=>pointsOrientation(start, end)
;
const segmentFromPoints = (points)=>{
    const seg = [];
    for(let i = 0; i < points.length; i += 2){
        // if it's an uneven number, dupe the last point
        const next = i + 1 === points.length ? i : i + 1;
        seg.push(segment(points[i][0], points[i][1], points[next][0], points[next][1]));
    }
    return seg;
};
const pointsFromSegment = (seg)=>{
    const points = [];
    for(let i = 0; i < seg.length; i++){
        points.push([
            seg[i].start.x,
            seg[i].start.y
        ]);
        points.push([
            seg[i].end.x,
            seg[i].end.y
        ]);
    }
    return points;
};
const a2p = (a)=>({
        x: a[0],
        y: a[1]
    })
;
const a2V = (a)=>new _vector.Vector(a[0], a[1])
;
const v2a = (v)=>[
        v.x,
        v.y
    ]
;
const a2pA = (arry)=>arry.map((a)=>a2p(a)
    )
;
const pa2VA = (arry)=>arry.map((a)=>a2V(a)
    )
;
const va2pA = (arry)=>arry.map((a)=>v2a(a)
    )
;
const flattenPointArray = (arry)=>arry.reduce((acc, p)=>{
        if (p) {
            acc.push(p[0]);
            acc.push(p[1]);
        }
        return acc;
    }, [])
;
const unflattenPointArray = (arry)=>{
    const points = [];
    for(let i = 0; i < arry.length; i += 2)points.push([
        arry[i],
        arry[i + 1]
    ]);
    return points;
};
const createSplinePoints = (points)=>{
    const fpoints = flattenPointArray(points);
    const curve = _curveCalc.getCurvePoints(fpoints);
    return unflattenPointArray(curve);
};
const reduceLineFromStart = (p1, p2, r)=>{
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const mag = Math.sqrt(dx * dx + dy * dy);
    return {
        x: p1.x + r * dx / mag,
        y: p1.y + r * dy / mag
    };
};
const reduceLineFromEnd = (p1, p2, r)=>{
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const mag = Math.sqrt(dx * dx + dy * dy);
    return {
        x: p2.x - r * dx / mag,
        y: p2.y - r * dy / mag
    };
};
const reduceLineEqually = (p1, p2, r)=>{
    const r2 = r / 2;
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const mag = Math.sqrt(dx * dx + dy * dy);
    return [
        {
            x: p1.x + r2 * dx / mag,
            y: p1.y + r2 * dy / mag
        },
        {
            x: p2.x - r2 * dx / mag,
            y: p2.y - r2 * dy / mag
        }, 
    ];
};
const intersect = (x1, y1, x2, y2, x3, y3, x4, y4)=>{
    // Check if none of the lines are of length 0
    if (x1 === x2 && y1 === y2 || x3 === x4 && y3 === y4) return false;
    const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    // Lines are parallel
    if (denominator === 0) return false;
    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
    const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
    // is the intersection along the segments
    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return false;
    // Return a object with the x and y coordinates of the intersection
    const x = x1 + ua * (x2 - x1);
    const y = y1 + ua * (y2 - y1);
    return {
        x,
        y
    };
};
