var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flowFieldRibbons2", ()=>flowFieldRibbons2
);
var _tinycolor2 = require("tinycolor2");
var _tinycolor2Default = parcelHelpers.interopDefault(_tinycolor2);
var _random = require("canvas-sketch-util/random");
var _randomDefault = parcelHelpers.interopDefault(_random);
var _math = require("../lib/math/math");
var _particle = require("../systems/Particle");
var _canvas = require("../lib/canvas/canvas");
var _sketch = require("../lib/Sketch");
var _palettes = require("../lib/color/palettes");
var _vector = require("../lib/math/Vector");
var _attractors = require("../lib/math/attractors");
var _rendernoise = require("../lib/canvas/rendernoise");
/*
Based on
https://tylerxhobbs.com/essays/2020/flow-fields
 */ const drawRibbonPoint = (context, point, i, thickness = 0, height = 0)=>{
    const x = point[0];
    const y = point[1];
    const jitterX = 0; // Math.cos(i * 0.05) * height;
    const jitterY = 0; // Math.sin(i * 0.05) * height;
    context.lineTo(x + thickness + jitterX, y + thickness + jitterY);
};
const drawRibbonSegment = (context, sideA, sideB, color, stroke = false, thickness = 1)=>{
    const segStartX = sideA[0][0];
    const segStartY = sideA[0][1];
    const segEndX = sideB[0][0] + thickness;
    const segEndY = sideB[0][1] + thickness;
    const rColor = _tinycolor2Default.default(color).clone();
    const gradient = context.createLinearGradient(0, segStartY - thickness, 0, segEndY + thickness);
    gradient.addColorStop(0, rColor.toRgbString());
    gradient.addColorStop(0.5, rColor.toRgbString());
    gradient.addColorStop(1, rColor.clone().darken(20).saturate(50).toRgbString());
    context.beginPath();
    context.moveTo(segStartX, segStartY);
    sideA.forEach((w, i)=>{
        drawRibbonPoint(context, w, i, 0, thickness * 0.1);
    });
    sideB.forEach((w, i)=>{
        drawRibbonPoint(context, w, i, thickness, thickness * 0.1);
    });
    context.lineTo(segStartX, segStartY);
    if (stroke) {
        context.strokeStyle = rColor.darken(70).toRgbString();
        context.lineWidth = 0.75;
        context.stroke();
    }
    context.fillStyle = gradient;
    context.fill();
};
const drawRibbon = (context)=>(sideA, sideB, color, stroke = false, thickness = 1)=>{
        const segmentGap = 1; // randomWholeBetween(1, 4);
        const segments = _math.randomWholeBetween(1, 3);
        // const segmentsStep = Math.ceil((sideA.length - segmentGap * (segments - 1)) / segments);
        const segmentData = [];
        let left = sideA.length;
        let start = 0;
        for(let i = 0; i < segments; i++){
            const len = _math.randomWholeBetween(1, left / 2);
            // const start = i * segmentsStep + segmentGap * i;
            // const len = segmentsStep;
            segmentData.push({
                sideA: sideA.slice(start, start + len),
                sideB: sideB.slice(start, start + len).reverse()
            });
            start += len + segmentGap;
            left -= len + segmentGap;
        }
        segmentData.forEach((s)=>{
            drawRibbonSegment(context, s.sideA, s.sideB, color, stroke, thickness);
        });
    // drawRibbonSegment(context, segmentStart, segmentLen, sideA, sideB, color, stroke, thickness);
    }
;
const flowFieldRibbons2 = ()=>{
    const config = {
        name: 'flowFieldRibbons',
        ratio: _sketch.ratio.square,
        scale: _sketch.scale.standard
    };
    let canvasMidX;
    let canvasMidY;
    const palette = _palettes.palettes['80s_pop'];
    const backgroundColor = _tinycolor2Default.default('white');
    let time = 0;
    const createRibbon = (fieldFn, startX, startY, length, vlimit = 1)=>{
        const props = {
            x: startX,
            y: startY,
            velocityX: 0,
            velocityY: 0,
            mass: 1
        };
        const particle = new _particle.Particle(props);
        const coords = [];
        for(let i = 0; i < length; i++){
            const theta = fieldFn(particle.x, particle.y);
            // theta = quantize(4, theta);
            const force = _math.uvFromAngle(theta);
            particle.applyForce(force);
            particle.velocity = particle.velocity.limit(vlimit);
            particle.updatePosWithVelocity();
            coords.push([
                particle.x,
                particle.y
            ]);
            particle.acceleration = new _vector.Vector(0, 0);
        }
        return coords;
    };
    const simplex2d = (x, y)=>_attractors.simplexNoise2d(x, y, 0.0001)
    ;
    const simplex3d = (x, y)=>_attractors.simplexNoise3d(x, y, time, 0.0005)
    ;
    const clifford = (x, y)=>_attractors.cliffordAttractor(canvas.width, canvas.height, x, y)
    ;
    const jong = (x, y)=>_attractors.jongAttractor(canvas.width, canvas.height, x, y)
    ;
    const noise = _math.randomBoolean() ? clifford : jong;
    let maxRadius;
    const setup = ({ canvas , context  })=>{
        canvasMidX = canvas.width / 2;
        canvasMidY = canvas.height / 2;
        maxRadius = canvas.width * 0.4;
        _canvas.background(canvas, context)(backgroundColor);
    // renderField(
    //     canvas,
    //     context,
    //     noise,
    //     tinycolor(oneOf(palette)).lighten(30),
    //     canvas.width / 10,
    //     canvas.width / 20
    // );
    };
    const ribbonLen = _math.randomWholeBetween(200, 500);
    const ribbonThickness = _math.randomWholeBetween(100, 300);
    const maxItterations = _math.randomWholeBetween(10, 30);
    let currentItteration = 0;
    const draw = ({ canvas , context  })=>{
        const color = _math.oneOf(palette);
        const len = ribbonLen;
        // const rpoint = random.onCircle(maxRadius); // randomPointAround(maxRadius * 0.4);
        const rpoint = [
            _math.randomWholeBetween(0, canvas.width),
            _math.randomWholeBetween(0, canvas.height)
        ];
        const x = rpoint[0];
        const y = rpoint[1];
        const x2 = x + 2;
        const y2 = y;
        const sideA = createRibbon(noise, x, y, len, 1);
        const sideB = createRibbon(noise, x2, y2, len, 1);
        drawRibbon(context)(sideA, sideB, color, false, ribbonThickness);
        time += 0.01;
        if ((++currentItteration) > maxItterations) return -1;
    };
    return {
        config,
        setup,
        draw
    };
};
