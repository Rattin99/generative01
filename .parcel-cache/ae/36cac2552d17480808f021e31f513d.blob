var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "turtleLineMode", ()=>turtleLineMode
);
parcelHelpers.export(exports, "plotLines", ()=>plotLines
);
parcelHelpers.export(exports, "drawPoints", ()=>drawPoints
);
parcelHelpers.export(exports, "drawConnectedPoints", ()=>drawConnectedPoints
);
parcelHelpers.export(exports, "drawPointsTaper", ()=>drawPointsTaper
);
parcelHelpers.export(exports, "circleAtPoint", ()=>circleAtPoint
);
parcelHelpers.export(exports, "variableCircleAtPoint", ()=>variableCircleAtPoint
);
parcelHelpers.export(exports, "drawSegment", ()=>drawSegment
);
parcelHelpers.export(exports, "drawSegmentTaper", ()=>drawSegmentTaper
);
var _tinycolor2 = require("tinycolor2");
var _tinycolor2Default = parcelHelpers.interopDefault(_tinycolor2);
var _canvas = require("./canvas");
var _math = require("../math/math");
let lineCap = 'butt';
let lineJoin = 'miter';
const turtleLineMode = (m = 'butt')=>{
    if (m === 'butt') {
        lineCap = 'butt';
        lineJoin = 'miter';
    } else if (m === 'round') {
        lineCap = 'round';
        lineJoin = 'round';
    }
};
const plotLines = (context)=>(points, color = 'black', width = 1)=>{
        context.beginPath();
        context.strokeStyle = _tinycolor2Default.default(color).toRgbString();
        context.lineWidth = width;
        context.lineCap = lineCap;
        context.lineJoin = lineJoin;
        points.forEach((coords, i)=>{
            if (i === 0) context.moveTo(coords[0], coords[1]);
            else context.lineTo(coords[0], coords[1]);
        });
        context.stroke();
    }
;
const drawPoints = (ctx)=>(points, color = 'black', width = 1)=>{
        points.forEach((coords, i)=>{
            _canvas.pixel(ctx)(coords[0], coords[1], color, 'circle', width);
        });
    }
;
const drawConnectedPoints = (ctx)=>(points, color = 'black', width = 1, close = false, drawPoint = false)=>{
        ctx.beginPath();
        ctx.strokeStyle = _tinycolor2Default.default(color).clone().toRgbString();
        ctx.lineWidth = width;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        points.forEach((coords, i)=>{
            if (i === 0) ctx.moveTo(coords[0], coords[1]);
            else ctx.lineTo(coords[0], coords[1]);
            if (drawPoint) _canvas.drawCircleFilled(ctx)(coords[0], coords[1], 1, 'red');
        });
        if (close) ctx.lineTo(points[0][0], points[0][1]);
        ctx.stroke();
    }
;
const drawPointsTaper = (ctx)=>(points, color = 'black', width = 1)=>{
        ctx.strokeStyle = _tinycolor2Default.default(color).clone().toRgbString();
        const mid = points.length / 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        points.forEach((coords, i)=>{
            const dist = Math.abs(mid - i);
            const w = _math.mapRange(0, mid, width, 1, dist);
            ctx.lineWidth = w;
            ctx.beginPath();
            ctx.moveTo(coords[0], coords[1]);
            ctx.lineTo(coords[0], coords[1]);
            ctx.stroke();
        });
    }
;
const circleAtPoint = (context)=>(points, color = 'black', radius = 5)=>{
        points.forEach((coords)=>{
            _canvas.drawCircleFilled(context)(coords[0], coords[1], radius, color);
        });
    }
;
const variableCircleAtPoint = (context)=>(points, color = 'black', radius = 5, freq = 10, amp = 2)=>{
        points.forEach((coords)=>{
            const v = Math.sin(coords[0] / freq) * amp;
            _canvas.drawCircleFilled(context)(coords[0], coords[1], Math.abs(radius - v), color);
        });
    }
;
const drawSegment = (ctx)=>(segments, color, weight, points = false)=>{
        ctx.lineCap = 'round';
        // ctx.lineJoin = 'round';
        ctx.strokeStyle = _tinycolor2Default.default(color).clone().toRgbString();
        ctx.lineWidth = weight;
        ctx.beginPath();
        segments.forEach((seg, i)=>{
            if (i === 0) ctx.moveTo(seg.start.x, seg.start.y);
            else ctx.lineTo(seg.start.x, seg.start.y);
            ctx.lineTo(seg.end.x, seg.end.y);
        });
        ctx.stroke();
        if (points) segments.forEach((seg, i)=>{
            const rad = i === 0 || i === segments.length - 1 ? 3 : 1;
            _canvas.drawCircleFilled(ctx)(seg.start.x, seg.start.y, rad, 'green');
            _canvas.drawCircleFilled(ctx)(seg.end.x, seg.end.y, rad, 'red');
        });
    }
;
const drawSegmentTaper = (ctx)=>(segments, color, maxWeight, minWeight = 1, points = false)=>{
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = _tinycolor2Default.default(color).clone().toRgbString();
        const mid = segments.length / 2;
        segments.forEach((seg, i)=>{
            const dist = Math.abs(mid - i);
            const w = _math.mapRange(0, mid, maxWeight, minWeight, dist);
            ctx.beginPath();
            ctx.lineWidth = w;
            if (i === 0) ctx.moveTo(seg.start.x, seg.start.y);
            else ctx.lineTo(seg.start.x, seg.start.y);
            ctx.lineTo(seg.end.x, seg.end.y);
            ctx.stroke();
        });
        if (points) segments.forEach((seg, i)=>{
            const rad = i === 0 || i === segments.length - 1 ? 3 : 1;
            _canvas.drawCircleFilled(ctx)(seg.start.x, seg.start.y, rad, 'green');
            _canvas.drawCircleFilled(ctx)(seg.end.x, seg.end.y, rad, 'red');
        });
    }
;
