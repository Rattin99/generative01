var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "variation1", ()=>variation1
);
var _particle = require("../systems/Particle");
var _canvas = require("../lib/canvas/canvas");
var _math = require("../lib/math/math");
var _canvasParticles = require("../lib/canvas/canvas-particles");
const gravityPoint = (mult = 0.2, f = 1)=>(x, y, radius, particle)=>{
        const distance = _math.pointDistance({
            x,
            y
        }, particle);
        if (distance < radius) {
            const dx = x - particle.x;
            const dy = y - particle.y;
            const forceDirectionX = dx / distance;
            const forceDirectionY = dy / distance;
            const force = _math.normalizeInverse(0, radius, distance) * f * mult;
            const tempX = forceDirectionX * force * particle.radius * 2;
            const tempY = forceDirectionY * force * particle.radius * 2;
            particle.x += tempX;
            particle.y += tempY;
        }
    }
;
// for moving points, push away/around from point
const avoidPoint = (point, particle, f = 1)=>{
    gravityPoint(1, f *= -1)(point.x, point.y, point.radius, particle);
};
// for moving points, pull towards point
const attractPoint = (point, particle, f = 1)=>{
    gravityPoint(1, f)(point.x, point.y, point.radius, particle);
};
const variation1 = ()=>{
    const numParticles = 100;
    const particlesArray = [];
    let canvasCenterX;
    let canvasCenterY;
    let centerRadius;
    const setup = ({ canvas , context  })=>{
        canvasCenterX = canvas.width / 2;
        canvasCenterY = canvas.height / 2;
        centerRadius = canvas.height / 4;
        for(let i = 0; i < numParticles; i++){
            const props = _particle.createRandomParticleValues(canvas);
            props.radius = 5;
            particlesArray.push(new _particle.Particle(props));
        }
    };
    const draw = ({ canvas , context , mouse  })=>{
        _canvas.fillCanvas(canvas, context)();
        for(let i = 0; i < numParticles; i++){
            particlesArray[i].updatePosWithVelocity();
            _particle.edgeBounce(canvas, particlesArray[i]);
            avoidPoint({
                radius: centerRadius,
                x: canvasCenterX,
                y: canvasCenterY
            }, particlesArray[i], 4);
            attractPoint(mouse, particlesArray[i], mouse.isDown ? -1 : 1);
            _canvasParticles.drawParticlePoint(context)(particlesArray[i]);
            _canvasParticles.drawPointTrail(context)(particlesArray[i]);
        }
        _canvasParticles.connectParticles(context)(particlesArray, 200);
        _canvasParticles.drawMouse(context)(mouse);
    };
    return {
        setup,
        draw
    };
};
