var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flowFieldRibbons", ()=>flowFieldRibbons
);
var _tinycolor2 = require("tinycolor2");
var _tinycolor2Default = parcelHelpers.interopDefault(_tinycolor2);
var _random = require("canvas-sketch-util/random");
var _randomDefault = parcelHelpers.interopDefault(_random);
var _math = require("../lib/math/math");
var _particle = require("../systems/Particle");
var _canvas = require("../lib/canvas/canvas");
var _sketch = require("../lib/Sketch");
var _palettes = require("../lib/color/palettes");
var _vector = require("../lib/math/Vector");
var _attractors = require("../lib/math/attractors");
var _rendernoise = require("../lib/canvas/rendernoise");
/*
Based on
https://tylerxhobbs.com/essays/2020/flow-fields
 */ const drawRibbonPoint = (context, point, i, thickness = 0, height = 0)=>{
    const x = point[0];
    const y = point[1];
    const jitterX = 0; // Math.cos(i * 0.05) * height;
    const jitterY = 0; // Math.sin(i * 0.05) * height;
    context.lineTo(x + thickness + jitterX, y + thickness + jitterY);
};
const drawRibbon = (context)=>(sideA, sideB, color, stroke = false, thickness = 1)=>{
        const startx = sideA[0][0];
        const starty = sideA[0][1];
        const endx = sideB[0][0] + thickness;
        const endy = sideB[0][1] + thickness;
        const rColor = _tinycolor2Default.default(color).clone();
        const gradient = context.createLinearGradient(0, starty - thickness, 0, endy + thickness);
        gradient.addColorStop(0, rColor.toRgbString());
        gradient.addColorStop(1, rColor.clone().darken(20).toRgbString());
        context.beginPath();
        context.moveTo(startx, starty);
        sideA.forEach((w, i)=>{
            drawRibbonPoint(context, w, i, 0, thickness * 0.1);
        });
        sideB.forEach((w, i)=>{
            drawRibbonPoint(context, w, i, thickness, thickness * 0.1);
        });
        context.lineTo(startx, starty);
        if (stroke) {
            context.strokeStyle = rColor.darken(70).toRgbString();
            context.lineWidth = 0.75;
            context.stroke();
        }
        context.fillStyle = gradient;
        context.fill();
    }
;
const flowFieldRibbons = ()=>{
    const config = {
        name: 'flowFieldRibbons',
        ratio: _sketch.ratio.square,
        scale: _sketch.scale.standard
    };
    let canvasMidX;
    let canvasMidY;
    const palette = _palettes.palettes.pop;
    const backgroundColor = _tinycolor2Default.default('white');
    let time = 0;
    const createRibbon = (fieldFn, startX, startY, length, vlimit = 1)=>{
        const props = {
            x: startX,
            y: startY,
            velocityX: 0,
            velocityY: 0,
            mass: 1
        };
        const particle = new _particle.Particle(props);
        const coords = [];
        for(let i = 0; i < length; i++){
            const theta = fieldFn(particle.x, particle.y);
            // theta = quantize(4, theta);
            const force = _math.uvFromAngle(theta);
            particle.applyForce(force);
            particle.velocity = particle.velocity.limit(vlimit);
            particle.updatePosWithVelocity();
            coords.push([
                particle.x,
                particle.y
            ]);
            particle.acceleration = new _vector.Vector(0, 0);
        }
        return coords;
    };
    const simplex2d = (x, y)=>_attractors.simplexNoise2d(x, y, 0.0005)
    ;
    const simplex3d = (x, y)=>_attractors.simplexNoise3d(x, y, time, 0.0005)
    ;
    const clifford = (x, y)=>_attractors.cliffordAttractor(canvas.width, canvas.height, x, y)
    ;
    const jong = (x, y)=>_attractors.jongAttractor(canvas.width, canvas.height, x, y)
    ;
    const noise = _math.randomBoolean() ? clifford : jong;
    let maxRadius;
    const setup = ({ canvas , context  })=>{
        canvasMidX = canvas.width / 2;
        canvasMidY = canvas.height / 2;
        maxRadius = canvas.width * 0.4;
        _canvas.background(canvas, context)(backgroundColor);
        _rendernoise.renderField(canvas, context, noise, 'rgba(0,0,0,.15)', canvas.width / 10, 5);
    };
    const ribbonLen = _math.randomWholeBetween(50, 1000);
    const ribbonThickness = _math.randomWholeBetween(3, 30);
    const draw = ({ canvas , context  })=>{
        const color = _math.oneOf(palette);
        const len = maxRadius * 2; // ribbonLen;
        const rpoint = _randomDefault.default.onCircle(maxRadius); // randomPointAround(maxRadius * 0.4);
        const x = rpoint[0] + canvasMidX;
        const y = rpoint[1] + canvasMidY;
        const x2 = x + 2;
        const y2 = y;
        const sideA = createRibbon(noise, x, y, len, 1);
        const sideB = createRibbon(noise, x2, y2, len, 1).reverse();
        drawRibbon(context)(sideA, sideB, color, false, ribbonThickness);
        time += 0.01;
    };
    return {
        config,
        setup,
        draw
    };
};
