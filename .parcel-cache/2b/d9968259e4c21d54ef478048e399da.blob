var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "variation5", ()=>variation5
);
var _particle = require("../systems/Particle");
var _canvas = require("../lib/canvas/canvas");
var _math = require("../lib/math/math");
var _canvasParticles = require("../lib/canvas/canvas-particles");
const gravityPoint = (mult = 0.2, f = 1)=>(x, y, radius, particle)=>{
        const distance = _math.pointDistance({
            x,
            y
        }, particle);
        if (distance < radius) {
            const dx = x - particle.x;
            const dy = y - particle.y;
            const forceDirectionX = dx / distance;
            const forceDirectionY = dy / distance;
            const force = _math.normalizeInverse(0, radius, distance) * f * mult;
            const tempX = forceDirectionX * force * particle.radius * 2;
            const tempY = forceDirectionY * force * particle.radius * 2;
            particle.x += tempX;
            particle.y += tempY;
        }
    }
;
// for moving points, push away/around from point
const avoidPoint = (point, particle, f = 1)=>{
    gravityPoint(1, f *= -1)(point.x, point.y, point.radius, particle);
};
const variation5 = ()=>{
    const config = {
        numParticles: 50
    };
    const particlesArray = [];
    const circles = [];
    const setup = ({ canvas , context  })=>{
        for(let i = 0; i < config.numParticles; i++){
            const props = _particle.createRandomParticleValues(canvas);
            props.x = canvas.width / 2;
            props.y = canvas.height / 2;
            props.color = {
                r: 0,
                g: 0,
                b: 0
            };
            props.radius = 0.5;
            particlesArray.push(new _particle.Particle(props));
        }
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const diameter = canvas.height / 4;
        const steps = 30;
        for(let theta = 0; theta < 360; theta += steps){
            const rad = theta * (Math.PI / 180);
            const x = Math.cos(rad) * diameter + centerX;
            const y = Math.sin(rad) * diameter + centerY;
            circles.push([
                x,
                y,
                _math.randomNumberBetween(20, 100)
            ]);
        }
        _canvas.fillCanvas(canvas, context)(1, '255,255,255');
    };
    const draw = ({ canvas , context , mouse  })=>{
        // fillCanvas(canvas, context)(.005,'255,255,255');
        for(let i = 0; i < config.numParticles; i++){
            particlesArray[i].updatePosWithVelocity();
            _particle.edgeBounce(canvas, particlesArray[i]);
            for(let c = 0; c < circles.length; c++)avoidPoint({
                radius: circles[c][2],
                x: circles[c][0],
                y: circles[c][1]
            }, particlesArray[i], 4);
            _canvasParticles.drawParticlePoint(context)(particlesArray[i]);
        }
        _canvasParticles.connectParticles(context)(particlesArray, 50);
    };
    return {
        config,
        setup,
        draw
    };
};
