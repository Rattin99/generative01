var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getCurvePoints", ()=>getCurvePoints
);
const getCurvePoints = (points, tension, numOfSeg, close)=>{
    // options or defaults
    tension = typeof tension === 'number' ? tension : 0.5;
    numOfSeg = numOfSeg || 25;
    let pts; // for cloning point array
    let i = 1;
    let l = points.length;
    let rPos = 0;
    const rLen = (l - 2) * numOfSeg + 2 + (close ? 2 * numOfSeg : 0);
    if (rLen < 0) return [];
    const res = new Float32Array(rLen);
    const cache = new Float32Array((numOfSeg + 2) * 4);
    let cachePtr = 4;
    pts = points.slice(0);
    if (close) {
        pts.unshift(points[l - 1]); // insert end point as first point
        pts.unshift(points[l - 2]);
        pts.push(points[0], points[1]); // first point as last point
    } else {
        pts.unshift(points[1]); // copy 1. point and insert at beginning
        pts.unshift(points[0]);
        pts.push(points[l - 2], points[l - 1]); // duplicate end-points
    }
    // cache inner-loop calculations as they are based on t alone
    cache[0] = 1; // 1,0,0,0
    for(; i < numOfSeg; i++){
        const st = i / numOfSeg;
        const st2 = st * st;
        const st3 = st2 * st;
        const st23 = st3 * 2;
        const st32 = st2 * 3;
        cache[cachePtr++] = st23 - st32 + 1; // c1
        cache[cachePtr++] = st32 - st23; // c2
        cache[cachePtr++] = st3 - 2 * st2 + st; // c3
        cache[cachePtr++] = st3 - st2; // c4
    }
    cache[++cachePtr] = 1; // 0,1,0,0
    // calc. points
    parse(pts, cache, l);
    if (close) {
        // l = points.length;
        pts = [];
        pts.push(points[l - 4], points[l - 3], points[l - 2], points[l - 1]); // second last and last
        pts.push(points[0], points[1], points[2], points[3]); // first and second
        parse(pts, cache, 4);
    }
    function parse(pts1, cache1, l1) {
        for(var i1 = 2, t; i1 < l1; i1 += 2){
            const pt1 = pts1[i1];
            const pt2 = pts1[i1 + 1];
            const pt3 = pts1[i1 + 2];
            const pt4 = pts1[i1 + 3];
            const t1x = (pt3 - pts1[i1 - 2]) * tension;
            const t1y = (pt4 - pts1[i1 - 1]) * tension;
            const t2x = (pts1[i1 + 4] - pt1) * tension;
            const t2y = (pts1[i1 + 5] - pt2) * tension;
            for(t = 0; t < numOfSeg; t++){
                const c = t << 2; // t * 4;
                const c1 = cache1[c];
                const c2 = cache1[c + 1];
                const c3 = cache1[c + 2];
                const c4 = cache1[c + 3];
                res[rPos++] = c1 * pt1 + c2 * pt3 + c3 * t1x + c4 * t2x;
                res[rPos++] = c1 * pt2 + c2 * pt4 + c3 * t1y + c4 * t2y;
            }
        }
    }
    // add last point
    l = close ? 0 : points.length - 2;
    res[rPos++] = points[l];
    res[rPos] = points[l + 1];
    return res;
};
