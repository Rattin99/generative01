var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "variation4", ()=>variation4
);
var _particle = require("../systems/Particle");
var _canvas = require("../lib/canvas/canvas");
var _math = require("../lib/math/math");
var _canvasParticles = require("../lib/canvas/canvas-particles");
const pointPush = (point, particle, f = 1)=>{
    const dx = point.x - particle.x;
    const dy = point.y - particle.y;
    const distance = _math.pointDistance(point, particle);
    const forceDirectionX = dx / distance;
    const forceDirectionY = dy / distance;
    const force = _math.normalizeInverse(0, point.radius, distance) * f;
    particle.velocityX = forceDirectionX * force * particle.mass * 0.8;
    particle.velocityY = forceDirectionY * force * particle.mass * 0.8;
    if (distance < point.radius) {
        particle.x -= particle.velocityX;
        particle.y -= particle.velocityY;
    } else {
        // TODO if < 1 then snap to 0
        if (particle.x !== particle.oX) particle.x -= (particle.x - particle.oX) * 0.1;
        if (particle.y !== particle.oY) particle.y -= (particle.y - particle.oY) * 0.1;
    }
};
const variation4 = ()=>{
    const config = {
        numParticles: 0
    };
    const particlesArray = [];
    const circles = [];
    const setup = ({ canvas , context  })=>{
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const diameter = canvas.height / 4;
        const steps = 10;
        for(let theta = 0; theta < 360; theta += steps){
            const rad = theta * (Math.PI / 180);
            const x = Math.cos(rad) * diameter + centerX;
            const y = Math.sin(rad) * diameter + centerY;
            circles.push([
                x,
                y
            ]);
            const props = _particle.createRandomParticleValues(canvas);
            props.x = x;
            props.y = y;
            props.radius = 1;
            props.color = {
                r: 0,
                g: 0,
                b: 0
            };
            props.index = circles.length - 1;
            particlesArray.push(new _particle.Particle(props));
        }
        config.numParticles = particlesArray.length;
        _canvas.fillCanvas(canvas, context)(1, '255,255,255');
    };
    // will run every frame
    const draw = ({ canvas , context , mouse  })=>{
        _canvas.fillCanvas(canvas, context)(0.005, '255,255,255');
        for(let i = 0; i < config.numParticles; i++){
            pointPush(mouse, particlesArray[i], mouse.isDown ? -1 : 5);
            _canvasParticles.drawParticlePoint(context)(particlesArray[i]);
        // let index = particlesArray[i].index + 1;
        // if(index === circles.length) {
        //     index = 0;
        // }
        // particlesArray[i].x = circles[index][0];
        // particlesArray[i].y = circles[index][1];
        // particlesArray.index = index;
        }
        _canvasParticles.connectParticles(context)(particlesArray, 200);
        return 1; // -1 to exit animation loop
    };
    return {
        config,
        setup,
        draw
    };
};
